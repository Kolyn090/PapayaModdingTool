using System;
using System.Collections.Generic;
using System.IO;
using AssetsTools.NET;
using AssetsTools.NET.Extra;
using AssetsTools.NET.Texture;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;
using UnityEngine;

using TextureFormat = AssetsTools.NET.Texture.TextureFormat;
using System.Globalization;
using System.Linq;
using PapayaModdingTool.Assets.Script.__Test__.TestUtil;
using PapayaModdingTool.Assets.Script.Misc.AppCore;
using PapayaModdingTool.Assets.Script.Reader;
using PapayaModdingTool.Assets.Script.__Test__;

namespace UABS.Assets.Script.__Test__
{
    public class TestEditTexture : MonoBehaviour, ITestable
    {
        public void Test(Action onComplete)
        {
            TestHelper.TestOnCleanLabDesk(() =>
            {
                AppEnvironment appEnvironment = new();
                BundleReader bundleReader = new(appEnvironment.AssetsManager, appEnvironment.Dispatcher);
                string DATA_PATH = Path.Combine(PredefinedTestPaths.LabDeskPath, "GameData");
                string bundlePath = Path.Combine(DATA_PATH, "spriteassetgroup_assets_assets/needdynamicloadresources/spritereference/unit_hero_gangdan.asset_266134690b1c6daffbecb67815ff8868.bundle");

                (BundleFileInstance bunInst, AssetsFileInstance assetInst) = bundleReader.ReadBundle(bundlePath);
                long texturePathID = -5051031092977008815;
                string ASSET_PATH = Path.Combine(PredefinedTestPaths.LabDeskPath, "Asset");
                string texture4ReplacePath = Path.Combine(ASSET_PATH, "spriteassetgroup_assets_assets/needdynamicloadresources/spritereference/unit_hero_gangdan-CAB-7570f5ae7807c50c425af095d0113220--5051031092977008815.png");
                ReplaceTexture(appEnvironment, appEnvironment.AssetsManager, assetInst, bunInst, texturePathID, texture4ReplacePath, bundlePath);
                onComplete?.Invoke();
            });
        }

        private void ReplaceTexture(AppEnvironment appEnvironment,
                                    AssetsManager am,
                                    AssetsFileInstance assetInst,
                                    BundleFileInstance bunInst,
                                    long pathID,
                                    string textureImagePath,
                                    string bundlePath)
        {
            // EditTextureOption.cs - ExecutePlugin
            AssetFileInfo info = assetInst.file.GetAssetInfo(pathID);
            TextureHelper textureHelper = new(am);

            AssetTypeValueField texBase = textureHelper.GetByteArrayTexture(assetInst, info);
            TextureFile texFile = TextureFile.ReadTextureFile(texBase);
            bool hasMipMaps = texFile.m_MipMap;
            bool readable = texFile.m_IsReadable;
            int filterMode = texFile.m_TextureSettings.m_FilterMode;
            string anisotFilter = texFile.m_TextureSettings.m_Aniso.ToString();
            string mipmapBias = texFile.m_TextureSettings.m_MipBias.ToString();
            int wrapmodeU = texFile.m_TextureSettings.m_WrapU;
            int wrapmodeV = texFile.m_TextureSettings.m_WrapV;
            string lightmapFormat = "0x" + texFile.m_LightmapFormat.ToString("X2");
            int colorSpace = texFile.m_ColorSpace;

            // EditDialog.axaml.cs - BtnSave_Click
            uint platform = assetInst.file.Metadata.TargetPlatform;
            byte[] platformBlob = textureHelper.GetPlatformBlob(texBase);
            Image<Rgba32> imgToImport = Image.Load<Rgba32>(textureImagePath);
            int format = texBase["m_TextureFormat"].AsInt;

            int mips = 1;
            if (!texBase["m_MipCount"].IsDummy)
                mips = texBase["m_MipCount"].AsInt;
            else if (textureHelper.IsPo2(imgToImport.Width) && textureHelper.IsPo2(imgToImport.Height))
                mips = textureHelper.GetMaxMipCount(imgToImport.Width, imgToImport.Height);

            int width = 0, height = 0;
            byte[] encImageBytes = null;
            encImageBytes = TextureImportExport.Import(imgToImport, (TextureFormat)format, out width, out height, ref mips, platform, platformBlob);
            
            // Test
            var streamPath = texBase["m_StreamData"]["path"].AsString;
            string searchPath = streamPath.StartsWith("archive:/") ? streamPath.Substring(9) : streamPath;
            searchPath = Path.GetFileName(searchPath);
            var dirInfo = bunInst.file.BlockAndDirInfo.DirectoryInfos.FirstOrDefault(d => d.Name == searchPath);
            byte[] originalBytes;
            using (var fs = File.OpenRead(bunInst.path))
            {
                // Position at start of .resS data inside bundle
                fs.Position = dirInfo.Offset + texBase["m_StreamData"]["offset"].AsLong;
                
                // Read the texture data size bytes
                originalBytes = new byte[texBase["m_StreamData"]["size"].AsInt];
                fs.Read(originalBytes, 0, originalBytes.Length);

                // Now originalBytes has the texture's BC7 raw data
            }

            byte[] ddsBytes = CreateDDSHeaderForBC7(width, height, originalBytes.Length).Concat(originalBytes).ToArray();
            File.WriteAllBytes("originalTexture.dds", ddsBytes);

            // Try with BCnEncoder
            // ITextureDecoder textureDecoder = appEnvironment.Wrapper.TextureDecoder;
            // byte[] rgbaBytes = new byte[width * height * 4];
            // imgToImport.CopyPixelDataTo(rgbaBytes);
            // byte[] imageBytes = rgbaBytes;
            // if (IsSupportedFormat((TextureFormat)format, out TextureCompressionFormat compressFormat))
            // {
            //     encImageBytes = textureDecoder.EncodeToBytes(textureImagePath, TextureCompressionFormat.Rgba);
            //     texBase["m_TextureFormat"].AsInt = 4; // RGBA32
            //     // encImageBytes = textureDecoder.DecodeToBytes(imageBytes, width, height, compressFormat);
            // }

            if (encImageBytes == null)
            {
                Debug.LogError($"Failed to encode texture format {(TextureFormat)format}!");
                return;
            }

            texBase["m_StreamData"]["offset"].AsInt = 0;
            // texBase["m_StreamData"]["size"].AsInt = 0;

            if (!texBase["m_MipMap"].IsDummy)
                texBase["m_MipMap"].AsBool = hasMipMaps;

            if (!texBase["m_MipCount"].IsDummy)
                texBase["m_MipCount"].AsInt = mips;

            if (!texBase["m_ReadAllowed"].IsDummy)
                texBase["m_ReadAllowed"].AsBool = readable;

            texBase["m_TextureSettings"]["m_FilterMode"].AsInt = filterMode;
            texBase["m_TextureSettings"]["m_Aniso"].AsInt = int.Parse(anisotFilter);
            texBase["m_TextureSettings"]["m_MipBias"].AsInt = int.Parse(mipmapBias);

            if (!texBase["m_TextureSettings"]["m_WrapU"].IsDummy)
                texBase["m_TextureSettings"]["m_WrapU"].AsInt = wrapmodeU;

            if (!texBase["m_TextureSettings"]["m_WrapV"].IsDummy)
                texBase["m_TextureSettings"]["m_WrapV"].AsInt = wrapmodeV;

            if (lightmapFormat.StartsWith("0x"))
            {
                if (int.TryParse(lightmapFormat, NumberStyles.HexNumber, CultureInfo.CurrentCulture, out int lightFmt))
                    texBase["m_LightmapFormat"].AsInt = lightFmt;
            }
            else
            {
                if (int.TryParse(lightmapFormat, out int lightFmt))
                    texBase["m_LightmapFormat"].AsInt = lightFmt;
            }

            if (!texBase["m_ColorSpace"].IsDummy)
                texBase["m_ColorSpace"].AsInt = colorSpace;

            texBase["m_TextureFormat"].AsInt = format;

            if (!texBase["m_CompleteImageSize"].IsDummy)
                texBase["m_CompleteImageSize"].AsInt = encImageBytes.Length;

            texBase["m_StreamData"]["size"].AsInt = encImageBytes.Length;

            texBase["m_Width"].AsInt = width;
            texBase["m_Height"].AsInt = height;

            // TextureFile.StreamingInfo streamInfo = texFile.m_StreamData;
            // if (streamInfo.path != null && streamInfo.path != "" && assetInst.parentBundle != null)
            // {
            //     string searchPath = streamInfo.path;
            //     if (searchPath.StartsWith("archive:/"))
            //         searchPath = searchPath.Substring(9);

            //     searchPath = Path.GetFileName(searchPath);
            //     AssetsFileReader reader = bunInst.file.DataReader;
            //     AssetBundleDirectoryInfo[] dirInf = bunInst.file.BlockAndDirInfo.DirectoryInfos;
            //     for (int i = 0; i < dirInf.Length; i++)
            //     {
            //         AssetBundleDirectoryInfo bunInfo = dirInf[i];
            //         if (bunInfo.Name == searchPath)
            //         {
            //             reader.Position = bunInfo.Offset + (long)streamInfo.offset;
            //             texFile.pictureData = reader.ReadBytes((int)streamInfo.size);
            //             texFile.m_StreamData.offset = 0;
            //             texFile.m_StreamData.size = 0;
            //             texFile.m_StreamData.path = "";
            //         }
            //     }
            // }

            // 1. Write patched asset to byte array
            byte[] savedAsset = texBase.WriteToByteArray();
            AssetsReplacerFromMemory replacer = new(
                info.PathId, info.TypeId, assetInst.file.GetScriptIndex(info), savedAsset);

            // 2. Write the modified assets file to a new memory stream
            byte[] modifiedAssetsFileBytes;
            using (MemoryStream ms = new MemoryStream())
            using (AssetsFileWriter w = new AssetsFileWriter(ms))
            {
                assetInst.file.Write(w, 0, new List<AssetsReplacer> { replacer });
                modifiedAssetsFileBytes = ms.ToArray();
            }

            // 3. Create a bundle replacer with the updated assets file
            string assetsFileNameInBundle = assetInst.name; // e.g. "cab-xxxx"
            BundleReplacer bunReplacer = new BundleReplacerFromMemory(
                assetsFileNameInBundle, // original name inside bundle
                null,                   // don't rename
                true,                   // has serialized data
                modifiedAssetsFileBytes,
                0,                      // offset
                modifiedAssetsFileBytes.Length
            );

            // 4. Write the new bundle to disk
            string newName = "~" + bunInst.name;
            string dir = Path.GetDirectoryName(bunInst.path)!;
            string filePath = Path.Combine(dir, newName);
            string origFilePath = bunInst.path;

            using (FileStream fs = File.Open(filePath, FileMode.Create))
            using (AssetsFileWriter w = new AssetsFileWriter(fs))
            {
                bunInst.file.Write(w, new List<BundleReplacer> { bunReplacer });
            }

            // 5. Overwrite original bundle file
            bunInst.file.Reader.Close();
            File.Delete(origFilePath);
            File.Move(filePath, origFilePath);

            // 6. Reload the new bundle
            bunInst.file = new AssetBundleFile();
            bunInst.file.Read(new AssetsFileReader(File.OpenRead(origFilePath)));

            am.UnloadAllBundleFiles();

            // var streamPath = texBase["m_StreamData"]["path"].AsString;
            // string searchPath = streamPath.StartsWith("archive:/") ? streamPath.Substring(9) : streamPath;
            // searchPath = Path.GetFileName(searchPath);
            // var dirInfo = bunInst.file.BlockAndDirInfo.DirectoryInfos.FirstOrDefault(d => d.Name == searchPath);
            if (dirInfo == null)
            {
                Debug.LogError("Could not find .resS entry in bundle directory.");
                return;
            }

            // foreach (var block in bunInst.file.BlockAndDirInfo.BlockInfos)
            // {
            //     Debug.Log($"Block flags: {block.GetCompressionType()}");
            // }
            // long expectedLength = ((width + 3) / 4) * ((height + 3) / 4) * 16;
            // Debug.Log($"Expected BC7 length: {expectedLength}");
            // Debug.Log($"Actual: {encImageBytes.Length}");

            using (var fs = new FileStream(bundlePath, FileMode.Open, FileAccess.ReadWrite, FileShare.None))
            {
                var header = CreateDDSHeaderForBC7(width, height, encImageBytes.Length);
                File.WriteAllBytes("view.dds", header.Concat(encImageBytes).ToArray());
                long writePos = dirInfo.Offset + texBase["m_StreamData"]["offset"].AsLong;
                fs.Position = writePos;

                // Debug.Log($"m_StreamData.path = '{streamPath}'");
                // Debug.Log($"m_StreamData.offset = {texBase["m_StreamData"]["offset"].AsLong}");
                // Debug.Log($"dirInfo.Offset = {dirInfo?.Offset}");

                // byte[] oldBytes = new byte[encImageBytes.Length];
                // fs.Read(oldBytes, 0, oldBytes.Length);
                // File.WriteAllBytes("old.dds", header.Concat(oldBytes).ToArray());

                fs.Write(encImageBytes, 0, encImageBytes.Length);
                fs.Flush();
            }
            /*
                // 2. Write patched assets file back to disk 
                string tempAssetPath = Path.Combine(Path.GetDirectoryName(bundlePath), "temp_assets.assets");
                using (FileStream fs = File.Create(tempAssetPath))
                using (AssetsFileWriter writer = new(fs))
                {
                    assetInst.file.Write(writer, 0, replacers, am.ClassDatabase);
                }

                var streamPath = texBase["m_StreamData"]["path"].AsString;
                string searchPath = streamPath.StartsWith("archive:/") ? streamPath.Substring(9) : streamPath;
                searchPath = Path.GetFileName(searchPath);

                // Find the directory info inside the bundle file
                var dirInfo = bunInst.file.BlockAndDirInfo.DirectoryInfos.FirstOrDefault(d => d.Name == searchPath);
                if (dirInfo == null)
                {
                    Debug.LogError("Could not find .resS entry in bundle directory.");
                    return;
                }

                am.UnloadAllBundleFiles();

                // Write the raw .resS bytes at the correct position inside the bundle file
                using (var fs = new FileStream(bundlePath, FileMode.Open, FileAccess.Write, FileShare.None))
                {
                    long writePos = dirInfo.Offset + texBase["m_StreamData"]["offset"].AsLong;
                    fs.Position = writePos;
                    fs.Write(encImageBytes, 0, encImageBytes.Length);
                    fs.Flush();
                }

                if (File.Exists(tempAssetPath))
                {
                    File.Delete(tempAssetPath);
                }
            */
        }

        byte[] CreateDDSHeaderForBC7(int width, int height, int dataSize)
        {
            byte[] header = new byte[128];

            // 'DDS '
            header[0] = (byte)'D';
            header[1] = (byte)'D';
            header[2] = (byte)'S';
            header[3] = (byte)' ';

            // dwSize
            BitConverter.GetBytes(124).CopyTo(header, 4);

            // dwFlags: CAPS | HEIGHT | WIDTH | PIXELFORMAT | LINEARSIZE
            BitConverter.GetBytes(0x00021007).CopyTo(header, 8);

            // dwHeight
            BitConverter.GetBytes(height).CopyTo(header, 12);

            // dwWidth
            BitConverter.GetBytes(width).CopyTo(header, 16);

            // dwPitchOrLinearSize
            BitConverter.GetBytes(dataSize).CopyTo(header, 20);

            // dwMipMapCount = 1
            BitConverter.GetBytes(1).CopyTo(header, 28);

            // pixel format size
            BitConverter.GetBytes(32).CopyTo(header, 76);

            // pixel format flags: DDPF_FOURCC
            BitConverter.GetBytes(0x00000004).CopyTo(header, 80);

            // FourCC = 'DX10'
            header[84] = (byte)'D';
            header[85] = (byte)'X';
            header[86] = (byte)'1';
            header[87] = (byte)'0';

            // DDS caps
            BitConverter.GetBytes(0x1000).CopyTo(header, 108); // DDSCAPS_TEXTURE

            // DX10 header starts at byte 128
            byte[] dx10Header = new byte[20];
            BitConverter.GetBytes(98).CopyTo(dx10Header, 0);   // DXGI_FORMAT_BC7_UNORM (value 98)
            BitConverter.GetBytes(3).CopyTo(dx10Header, 4);    // D3D10_RESOURCE_DIMENSION_TEXTURE2D
            BitConverter.GetBytes(0).CopyTo(dx10Header, 8);    // misc flag
            BitConverter.GetBytes(1).CopyTo(dx10Header, 12);   // array size
            BitConverter.GetBytes(0).CopyTo(dx10Header, 16);   // misc flags 2

            return header.Concat(dx10Header).ToArray();
        }

        private int IndexToTextureFormat(int format)
        {
            if (format >= 37)
                return format + 41 - 37;
            else
                return format + 1;
        }
    }
}